{"ast":null,"code":"import Node from './Node';\n\nclass Chess {\n  constructor(n) {\n    this.n = n;\n    this.path = [];\n  }\n\n  valid(x, y) {\n    if (x < 0 || y < 0 || x >= this.n || y >= this.n) return false;\n    return true;\n  }\n\n  printPath(node) {\n    if (node == null) {\n      return;\n    }\n\n    this.printPath(node.parent);\n    this.path.push({\n      x: node.x,\n      y: node.y\n    });\n  }\n\n  calcSteps(src, destination) {\n    let queue = [];\n    queue.push(src);\n    let visited = [];\n    const row = [2, 2, -2, -2, 1, 1, -1, -1];\n    const col = [-1, 1, 1, -1, 2, -2, 2, -2];\n\n    while (queue.length > 0) {\n      const currentNode = queue.shift();\n\n      if (currentNode.x === destination.x && currentNode.y === destination.y) {\n        this.printPath(currentNode);\n        return this.path;\n      }\n\n      const hasVisited = visited.find(item => item.x === currentNode.x && item.y === currentNode.y);\n\n      if (!hasVisited) {\n        visited.push(currentNode);\n\n        for (let i = 0; i < 8; i++) {\n          const x1 = currentNode.x + row[i];\n          const y1 = currentNode.y + col[i];\n\n          if (this.valid(x1, y1)) {\n            queue.push(new Node(x1, y1, currentNode.distance + 1, currentNode));\n          }\n        }\n      }\n    }\n\n    return 'not reachable';\n  }\n\n}\n\nexport default Chess;","map":{"version":3,"sources":["/Users/zachary/work/求职/chess_knight/frontend/src/class/Chess.js"],"names":["Node","Chess","constructor","n","path","valid","x","y","printPath","node","parent","push","calcSteps","src","destination","queue","visited","row","col","length","currentNode","shift","hasVisited","find","item","i","x1","y1","distance"],"mappings":"AAAA,OAAOA,IAAP,MAAiB,QAAjB;;AAEA,MAAMC,KAAN,CAAY;AACRC,EAAAA,WAAW,CAACC,CAAD,EAAI;AACX,SAAKA,CAAL,GAASA,CAAT;AACA,SAAKC,IAAL,GAAY,EAAZ;AACD;;AAEDC,EAAAA,KAAK,CAACC,CAAD,EAAIC,CAAJ,EAAO;AACV,QAAID,CAAC,GAAG,CAAJ,IAASC,CAAC,GAAG,CAAb,IAAkBD,CAAC,IAAI,KAAKH,CAA5B,IAAiCI,CAAC,IAAI,KAAKJ,CAA/C,EAAkD,OAAO,KAAP;AAClD,WAAO,IAAP;AACD;;AAEDK,EAAAA,SAAS,CAACC,IAAD,EAAO;AACd,QAAIA,IAAI,IAAI,IAAZ,EAAkB;AAChB;AACD;;AACD,SAAKD,SAAL,CAAeC,IAAI,CAACC,MAApB;AACA,SAAKN,IAAL,CAAUO,IAAV,CAAe;AAAEL,MAAAA,CAAC,EAAEG,IAAI,CAACH,CAAV;AAAaC,MAAAA,CAAC,EAAEE,IAAI,CAACF;AAArB,KAAf;AACD;;AAEDK,EAAAA,SAAS,CAACC,GAAD,EAAMC,WAAN,EAAmB;AAC1B,QAAIC,KAAK,GAAG,EAAZ;AACAA,IAAAA,KAAK,CAACJ,IAAN,CAAWE,GAAX;AAEA,QAAIG,OAAO,GAAG,EAAd;AACA,UAAMC,GAAG,GAAG,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAC,CAAR,EAAW,CAAC,CAAZ,EAAe,CAAf,EAAkB,CAAlB,EAAqB,CAAC,CAAtB,EAAyB,CAAC,CAA1B,CAAZ;AACA,UAAMC,GAAG,GAAG,CAAC,CAAC,CAAF,EAAK,CAAL,EAAQ,CAAR,EAAW,CAAC,CAAZ,EAAe,CAAf,EAAkB,CAAC,CAAnB,EAAsB,CAAtB,EAAyB,CAAC,CAA1B,CAAZ;;AAEA,WAAMH,KAAK,CAACI,MAAN,GAAe,CAArB,EAAwB;AACtB,YAAMC,WAAW,GAAGL,KAAK,CAACM,KAAN,EAApB;;AAEA,UAAGD,WAAW,CAACd,CAAZ,KAAkBQ,WAAW,CAACR,CAA9B,IAAmCc,WAAW,CAACb,CAAZ,KAAkBO,WAAW,CAACP,CAApE,EAAsE;AACpE,aAAKC,SAAL,CAAeY,WAAf;AACA,eAAO,KAAKhB,IAAZ;AACD;;AAED,YAAMkB,UAAU,GAAGN,OAAO,CAACO,IAAR,CAAaC,IAAI,IAAIA,IAAI,CAAClB,CAAL,KAAWc,WAAW,CAACd,CAAvB,IAA4BkB,IAAI,CAACjB,CAAL,KAAWa,WAAW,CAACb,CAAxE,CAAnB;;AAEA,UAAG,CAACe,UAAJ,EAAgB;AACdN,QAAAA,OAAO,CAACL,IAAR,CAAaS,WAAb;;AAEA,aAAI,IAAIK,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAG,CAAnB,EAAsBA,CAAC,EAAvB,EAA2B;AACzB,gBAAMC,EAAE,GAAGN,WAAW,CAACd,CAAZ,GAAgBW,GAAG,CAACQ,CAAD,CAA9B;AACA,gBAAME,EAAE,GAAGP,WAAW,CAACb,CAAZ,GAAgBW,GAAG,CAACO,CAAD,CAA9B;;AACA,cAAG,KAAKpB,KAAL,CAAWqB,EAAX,EAAeC,EAAf,CAAH,EAAuB;AACrBZ,YAAAA,KAAK,CAACJ,IAAN,CAAW,IAAIX,IAAJ,CAAS0B,EAAT,EAAaC,EAAb,EAAiBP,WAAW,CAACQ,QAAZ,GAAuB,CAAxC,EAA2CR,WAA3C,CAAX;AACD;AACF;AACF;AAEF;;AAED,WAAO,eAAP;AACD;;AApDK;;AAuDZ,eAAenB,KAAf","sourcesContent":["import Node from './Node';\n\nclass Chess {\n    constructor(n) {\n        this.n = n;\n        this.path = [];\n      }\n    \n      valid(x, y) {\n        if (x < 0 || y < 0 || x >= this.n || y >= this.n) return false;\n        return true;\n      }\n    \n      printPath(node) {\n        if (node == null) {\n          return;\n        }\n        this.printPath(node.parent);\n        this.path.push({ x: node.x, y: node.y })\n      }\n    \n      calcSteps(src, destination) {\n        let queue = [];\n        queue.push(src);\n  \n        let visited = [];\n        const row = [2, 2, -2, -2, 1, 1, -1, -1];\n        const col = [-1, 1, 1, -1, 2, -2, 2, -2];\n  \n        while(queue.length > 0) {\n          const currentNode = queue.shift();\n          \n          if(currentNode.x === destination.x && currentNode.y === destination.y){\n            this.printPath(currentNode);\n            return this.path;\n          }\n  \n          const hasVisited = visited.find(item => item.x === currentNode.x && item.y === currentNode.y);\n          \n          if(!hasVisited) {\n            visited.push(currentNode);\n  \n            for(let i = 0; i < 8; i++) {\n              const x1 = currentNode.x + row[i];\n              const y1 = currentNode.y + col[i];\n              if(this.valid(x1, y1)) {\n                queue.push(new Node(x1, y1, currentNode.distance + 1, currentNode))\n              }\n            }\n          }\n  \n        }\n  \n        return 'not reachable';\n      }\n}\n\nexport default Chess;"]},"metadata":{},"sourceType":"module"}