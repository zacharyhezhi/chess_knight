{"ast":null,"code":"class Chess {\n  constructor(n) {\n    this.n = n;\n    this.path = [];\n  }\n\n  valid(x, y) {\n    if (x < 0 || y < 0 || x >= this.n || y >= this.n) return false;\n    return true;\n  }\n\n  printPath(node) {\n    if (node == null) {\n      return;\n    }\n\n    this.printPath(node.parent);\n    this.path.push({\n      x: node.x,\n      y: node.y\n    });\n  }\n\n  calcSteps() {\n    let queue = [];\n    queue.push(src);\n    let visited = [];\n    const row = [2, 2, -2, -2, 1, 1, -1, -1];\n    const col = [-1, 1, 1, -1, 2, -2, 2, -2];\n\n    while (queue.length > 0) {\n      const currentNode = queue.shift();\n\n      if (currentNode.x === destination.x && currentNode.y === destination.y) {\n        this.printPath(currentNode);\n        return this.path;\n      }\n\n      const hasVisited = visited.find(item => item.x === currentNode.x && item.y === currentNode.y);\n\n      if (!hasVisited) {\n        visited.push(currentNode);\n\n        for (let i = 0; i < 8; i++) {\n          const x1 = currentNode.x + row[i];\n          const y1 = currentNode.y + col[i];\n\n          if (this.valid(x1, y1)) {\n            queue.push(new Node(x1, y1, currentNode.distance + 1, currentNode));\n          }\n        }\n      }\n    }\n\n    return 'not reachable';\n  }\n\n}\n\nexport default Chess;","map":{"version":3,"sources":["/Users/zachary/work/求职/chess_knight/frontend/src/chess/Chess.js"],"names":["Chess","constructor","n","path","valid","x","y","printPath","node","parent","push","calcSteps","queue","src","visited","row","col","length","currentNode","shift","destination","hasVisited","find","item","i","x1","y1","Node","distance"],"mappings":"AAAA,MAAMA,KAAN,CAAY;AACRC,EAAAA,WAAW,CAACC,CAAD,EAAI;AACX,SAAKA,CAAL,GAASA,CAAT;AACA,SAAKC,IAAL,GAAY,EAAZ;AACD;;AAEDC,EAAAA,KAAK,CAACC,CAAD,EAAIC,CAAJ,EAAO;AACV,QAAID,CAAC,GAAG,CAAJ,IAASC,CAAC,GAAG,CAAb,IAAkBD,CAAC,IAAI,KAAKH,CAA5B,IAAiCI,CAAC,IAAI,KAAKJ,CAA/C,EAAkD,OAAO,KAAP;AAClD,WAAO,IAAP;AACD;;AAEDK,EAAAA,SAAS,CAACC,IAAD,EAAO;AACd,QAAIA,IAAI,IAAI,IAAZ,EAAkB;AAChB;AACD;;AACD,SAAKD,SAAL,CAAeC,IAAI,CAACC,MAApB;AACA,SAAKN,IAAL,CAAUO,IAAV,CAAe;AAAEL,MAAAA,CAAC,EAAEG,IAAI,CAACH,CAAV;AAAaC,MAAAA,CAAC,EAAEE,IAAI,CAACF;AAArB,KAAf;AACD;;AAEDK,EAAAA,SAAS,GAAG;AACV,QAAIC,KAAK,GAAG,EAAZ;AACEA,IAAAA,KAAK,CAACF,IAAN,CAAWG,GAAX;AAEA,QAAIC,OAAO,GAAG,EAAd;AACA,UAAMC,GAAG,GAAG,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAC,CAAR,EAAW,CAAC,CAAZ,EAAe,CAAf,EAAkB,CAAlB,EAAqB,CAAC,CAAtB,EAAyB,CAAC,CAA1B,CAAZ;AACA,UAAMC,GAAG,GAAG,CAAC,CAAC,CAAF,EAAK,CAAL,EAAQ,CAAR,EAAW,CAAC,CAAZ,EAAe,CAAf,EAAkB,CAAC,CAAnB,EAAsB,CAAtB,EAAyB,CAAC,CAA1B,CAAZ;;AAEA,WAAMJ,KAAK,CAACK,MAAN,GAAe,CAArB,EAAwB;AACtB,YAAMC,WAAW,GAAGN,KAAK,CAACO,KAAN,EAApB;;AAEA,UAAGD,WAAW,CAACb,CAAZ,KAAkBe,WAAW,CAACf,CAA9B,IAAmCa,WAAW,CAACZ,CAAZ,KAAkBc,WAAW,CAACd,CAApE,EAAsE;AACpE,aAAKC,SAAL,CAAeW,WAAf;AACA,eAAO,KAAKf,IAAZ;AACD;;AAED,YAAMkB,UAAU,GAAGP,OAAO,CAACQ,IAAR,CAAaC,IAAI,IAAIA,IAAI,CAAClB,CAAL,KAAWa,WAAW,CAACb,CAAvB,IAA4BkB,IAAI,CAACjB,CAAL,KAAWY,WAAW,CAACZ,CAAxE,CAAnB;;AAEA,UAAG,CAACe,UAAJ,EAAgB;AACdP,QAAAA,OAAO,CAACJ,IAAR,CAAaQ,WAAb;;AAEA,aAAI,IAAIM,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAG,CAAnB,EAAsBA,CAAC,EAAvB,EAA2B;AACzB,gBAAMC,EAAE,GAAGP,WAAW,CAACb,CAAZ,GAAgBU,GAAG,CAACS,CAAD,CAA9B;AACA,gBAAME,EAAE,GAAGR,WAAW,CAACZ,CAAZ,GAAgBU,GAAG,CAACQ,CAAD,CAA9B;;AACA,cAAG,KAAKpB,KAAL,CAAWqB,EAAX,EAAeC,EAAf,CAAH,EAAuB;AACrBd,YAAAA,KAAK,CAACF,IAAN,CAAW,IAAIiB,IAAJ,CAASF,EAAT,EAAaC,EAAb,EAAiBR,WAAW,CAACU,QAAZ,GAAuB,CAAxC,EAA2CV,WAA3C,CAAX;AACD;AACF;AACF;AAEF;;AAED,WAAO,eAAP;AACH;;AApDK;;AAuDZ,eAAelB,KAAf","sourcesContent":["class Chess {\n    constructor(n) {\n        this.n = n;\n        this.path = [];\n      }\n    \n      valid(x, y) {\n        if (x < 0 || y < 0 || x >= this.n || y >= this.n) return false;\n        return true;\n      }\n    \n      printPath(node) {\n        if (node == null) {\n          return;\n        }\n        this.printPath(node.parent);\n        this.path.push({ x: node.x, y: node.y })\n      }\n    \n      calcSteps() {\n        let queue = [];\n          queue.push(src);\n    \n          let visited = [];\n          const row = [2, 2, -2, -2, 1, 1, -1, -1];\n          const col = [-1, 1, 1, -1, 2, -2, 2, -2];\n    \n          while(queue.length > 0) {\n            const currentNode = queue.shift();\n            \n            if(currentNode.x === destination.x && currentNode.y === destination.y){\n              this.printPath(currentNode);\n              return this.path;\n            }\n    \n            const hasVisited = visited.find(item => item.x === currentNode.x && item.y === currentNode.y);\n            \n            if(!hasVisited) {\n              visited.push(currentNode);\n    \n              for(let i = 0; i < 8; i++) {\n                const x1 = currentNode.x + row[i];\n                const y1 = currentNode.y + col[i];\n                if(this.valid(x1, y1)) {\n                  queue.push(new Node(x1, y1, currentNode.distance + 1, currentNode))\n                }\n              }\n            }\n    \n          }\n    \n          return 'not reachable';\n      }\n}\n\nexport default Chess;"]},"metadata":{},"sourceType":"module"}